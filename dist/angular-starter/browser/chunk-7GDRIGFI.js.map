{"version":3,"sources":["node_modules/@ngrx/signals/fesm2022/ngrx-signals.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { untracked, isSignal, computed, assertInInjectionContext, inject, Injector, effect, DestroyRef, signal, Injectable } from '@angular/core';\nfunction toDeepSignal(signal) {\n  const value = untracked(() => signal());\n  if (!isRecord(value)) {\n    return signal;\n  }\n  return new Proxy(signal, {\n    get(target, prop) {\n      if (!(prop in value)) {\n        return target[prop];\n      }\n      if (!isSignal(target[prop])) {\n        Object.defineProperty(target, prop, {\n          value: computed(() => target()[prop]),\n          configurable: true\n        });\n      }\n      return toDeepSignal(target[prop]);\n    }\n  });\n}\nconst nonRecords = [WeakSet, WeakMap, Promise, Date, Error, RegExp, ArrayBuffer, DataView, Function];\nfunction isRecord(value) {\n  if (value === null || typeof value !== 'object' || isIterable(value)) {\n    return false;\n  }\n  let proto = Object.getPrototypeOf(value);\n  if (proto === Object.prototype) {\n    return true;\n  }\n  while (proto && proto !== Object.prototype) {\n    if (nonRecords.includes(proto.constructor)) {\n      return false;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return proto === Object.prototype;\n}\nfunction isIterable(value) {\n  return typeof value?.[Symbol.iterator] === 'function';\n}\nfunction deepComputed(computation) {\n  return toDeepSignal(computed(computation));\n}\nfunction signalMethod(processingFn, config) {\n  if (!config?.injector) {\n    assertInInjectionContext(signalMethod);\n  }\n  const watchers = [];\n  const sourceInjector = config?.injector ?? inject(Injector);\n  const signalMethodFn = (input, config) => {\n    if (isSignal(input)) {\n      const callerInjector = getCallerInjector();\n      if (typeof ngDevMode !== 'undefined' && ngDevMode && config?.injector === undefined && callerInjector === undefined) {\n        console.warn('@ngrx/signals: The function returned by signalMethod was called', 'outside the injection context with a signal. This may lead to', 'a memory leak. Make sure to call it within the injection context', '(e.g. in a constructor or field initializer) or pass an injector', 'explicitly via the config parameter.\\n\\nFor more information, see:', 'https://ngrx.io/guide/signals/signal-method#automatic-cleanup');\n      }\n      const instanceInjector = config?.injector ?? callerInjector ?? sourceInjector;\n      const watcher = effect(() => {\n        const value = input();\n        untracked(() => processingFn(value));\n      }, {\n        injector: instanceInjector\n      });\n      watchers.push(watcher);\n      instanceInjector.get(DestroyRef).onDestroy(() => {\n        const ix = watchers.indexOf(watcher);\n        if (ix !== -1) {\n          watchers.splice(ix, 1);\n        }\n      });\n      return watcher;\n    } else {\n      processingFn(input);\n      return {\n        destroy: () => void true\n      };\n    }\n  };\n  signalMethodFn.destroy = () => watchers.forEach(watcher => watcher.destroy());\n  return signalMethodFn;\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch {\n    return undefined;\n  }\n}\nconst STATE_WATCHERS = new WeakMap();\nconst STATE_SOURCE = Symbol('STATE_SOURCE');\nfunction isWritableStateSource(stateSource) {\n  return 'set' in stateSource[STATE_SOURCE] && 'update' in stateSource[STATE_SOURCE] && typeof stateSource[STATE_SOURCE].set === 'function' && typeof stateSource[STATE_SOURCE].update === 'function';\n}\nfunction patchState(stateSource, ...updaters) {\n  stateSource[STATE_SOURCE].update(currentState => updaters.reduce((nextState, updater) => ({\n    ...nextState,\n    ...(typeof updater === 'function' ? updater(nextState) : updater)\n  }), currentState));\n  notifyWatchers(stateSource);\n}\nfunction getState(stateSource) {\n  return stateSource[STATE_SOURCE]();\n}\nfunction watchState(stateSource, watcher, config) {\n  if (!config?.injector) {\n    assertInInjectionContext(watchState);\n  }\n  const injector = config?.injector ?? inject(Injector);\n  const destroyRef = injector.get(DestroyRef);\n  addWatcher(stateSource, watcher);\n  watcher(getState(stateSource));\n  const destroy = () => removeWatcher(stateSource, watcher);\n  destroyRef.onDestroy(destroy);\n  return {\n    destroy\n  };\n}\nfunction getWatchers(stateSource) {\n  return STATE_WATCHERS.get(stateSource[STATE_SOURCE]) || [];\n}\nfunction notifyWatchers(stateSource) {\n  const watchers = getWatchers(stateSource);\n  for (const watcher of watchers) {\n    const state = untracked(() => getState(stateSource));\n    watcher(state);\n  }\n}\nfunction addWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], [...watchers, watcher]);\n}\nfunction removeWatcher(stateSource, watcher) {\n  const watchers = getWatchers(stateSource);\n  STATE_WATCHERS.set(stateSource[STATE_SOURCE], watchers.filter(w => w !== watcher));\n}\nfunction signalState(initialState) {\n  const stateSource = signal(initialState);\n  const signalState = toDeepSignal(stateSource.asReadonly());\n  Object.defineProperty(signalState, STATE_SOURCE, {\n    value: stateSource\n  });\n  return signalState;\n}\nfunction signalStore(...args) {\n  const signalStoreArgs = [...args];\n  const config = typeof signalStoreArgs[0] === 'function' ? {} : signalStoreArgs.shift();\n  const features = signalStoreArgs;\n  let SignalStore = /*#__PURE__*/(() => {\n    class SignalStore {\n      constructor() {\n        const innerStore = features.reduce((store, feature) => feature(store), getInitialInnerStore());\n        const {\n          stateSignals,\n          props,\n          methods,\n          hooks\n        } = innerStore;\n        const storeMembers = {\n          ...stateSignals,\n          ...props,\n          ...methods\n        };\n        this[STATE_SOURCE] = innerStore[STATE_SOURCE];\n        for (const key of Reflect.ownKeys(storeMembers)) {\n          this[key] = storeMembers[key];\n        }\n        const {\n          onInit,\n          onDestroy\n        } = hooks;\n        if (onInit) {\n          onInit();\n        }\n        if (onDestroy) {\n          inject(DestroyRef).onDestroy(onDestroy);\n        }\n      }\n      /** @nocollapse */\n      static Éµfac = function SignalStore_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || SignalStore)();\n      };\n      /** @nocollapse */\n      static Éµprov = /* @__PURE__ */i0.ÉµÉµdefineInjectable({\n        token: SignalStore,\n        factory: SignalStore.Éµfac,\n        providedIn: config.providedIn || null\n      });\n    }\n    return SignalStore;\n  })();\n  (() => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n  return SignalStore;\n}\nfunction getInitialInnerStore() {\n  return {\n    [STATE_SOURCE]: signal({}),\n    stateSignals: {},\n    props: {},\n    methods: {},\n    hooks: {}\n  };\n}\nfunction signalStoreFeature(featureOrInput, ...restFeatures) {\n  const features = typeof featureOrInput === 'function' ? [featureOrInput, ...restFeatures] : restFeatures;\n  return inputStore => features.reduce((store, feature) => feature(store), inputStore);\n}\nfunction type() {\n  return undefined;\n}\nfunction assertUniqueStoreMembers(store, newMemberKeys) {\n  if (typeof ngDevMode === 'undefined' || !ngDevMode) {\n    return;\n  }\n  const storeMembers = {\n    ...store.stateSignals,\n    ...store.props,\n    ...store.methods\n  };\n  const overriddenKeys = Reflect.ownKeys(storeMembers).filter(memberKey => newMemberKeys.includes(memberKey));\n  if (overriddenKeys.length > 0) {\n    console.warn('@ngrx/signals: SignalStore members cannot be overridden.', 'Trying to override:', overriddenKeys.map(key => String(key)).join(', '));\n  }\n}\nfunction withProps(propsFactory) {\n  return store => {\n    const props = propsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    assertUniqueStoreMembers(store, Reflect.ownKeys(props));\n    return {\n      ...store,\n      props: {\n        ...store.props,\n        ...props\n      }\n    };\n  };\n}\nfunction withComputed(signalsFactory) {\n  return withProps(signalsFactory);\n}\n\n/**\n * @description\n * Allows passing properties, methods, or signals from a SignalStore\n * to a feature.\n *\n * @usageNotes\n * ```typescript\n * signalStore(\n *   withMethods((store) => ({\n *     load(id: number): Observable<Entity> {\n *       return of({ id, name: 'John' });\n *     },\n *   })),\n *   withFeature(\n *     // ðŸ‘‡ has full access to the store\n *     (store) => withEntityLoader((id) => firstValueFrom(store.load(id)))\n *   )\n * );\n * ```\n *\n * @param featureFactory function returning the actual feature\n */\nfunction withFeature(featureFactory) {\n  return store => {\n    const storeForFactory = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store['stateSignals'],\n      ...store['props'],\n      ...store['methods']\n    };\n    return featureFactory(storeForFactory)(store);\n  };\n}\nfunction withHooks(hooksOrFactory) {\n  return store => {\n    const storeMembers = {\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    };\n    const hooks = typeof hooksOrFactory === 'function' ? hooksOrFactory(storeMembers) : hooksOrFactory;\n    const createHook = name => {\n      const hook = hooks[name];\n      const currentHook = store.hooks[name];\n      return hook ? () => {\n        if (currentHook) {\n          currentHook();\n        }\n        hook(storeMembers);\n      } : currentHook;\n    };\n    return {\n      ...store,\n      hooks: {\n        onInit: createHook('onInit'),\n        onDestroy: createHook('onDestroy')\n      }\n    };\n  };\n}\nfunction withMethods(methodsFactory) {\n  return store => {\n    const methods = methodsFactory({\n      [STATE_SOURCE]: store[STATE_SOURCE],\n      ...store.stateSignals,\n      ...store.props,\n      ...store.methods\n    });\n    assertUniqueStoreMembers(store, Reflect.ownKeys(methods));\n    return {\n      ...store,\n      methods: {\n        ...store.methods,\n        ...methods\n      }\n    };\n  };\n}\nfunction withState(stateOrFactory) {\n  return store => {\n    const state = typeof stateOrFactory === 'function' ? stateOrFactory() : stateOrFactory;\n    const stateKeys = Reflect.ownKeys(state);\n    assertUniqueStoreMembers(store, stateKeys);\n    store[STATE_SOURCE].update(currentState => ({\n      ...currentState,\n      ...state\n    }));\n    const stateSignals = stateKeys.reduce((acc, key) => {\n      const sliceSignal = computed(() => store[STATE_SOURCE]()[key]);\n      return {\n        ...acc,\n        [key]: toDeepSignal(sliceSignal)\n      };\n    }, {});\n    return {\n      ...store,\n      stateSignals: {\n        ...store.stateSignals,\n        ...stateSignals\n      }\n    };\n  };\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { deepComputed, getState, isWritableStateSource, patchState, signalMethod, signalState, signalStore, signalStoreFeature, type, watchState, withComputed, withFeature, withHooks, withMethods, withProps, withState };\n"],"mappings":"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","names":["toDeepSignal","signal","value","untracked","isRecord","target","prop","isSignal","computed","nonRecords","isIterable","proto","STATE_WATCHERS","STATE_SOURCE","patchState","stateSource","updaters","STATE_SOURCE","currentState","nextState","updater","__spreadValues","notifyWatchers","getState","getWatchers","stateSource","STATE_WATCHERS","STATE_SOURCE","notifyWatchers","watchers","watcher","state","untracked","getState","signalStore","args","signalStoreArgs","config","features","SignalStore","innerStore","store","feature","getInitialInnerStore","stateSignals","props","methods","hooks","storeMembers","__spreadValues","STATE_SOURCE","key","onInit","onDestroy","inject","DestroyRef","__ngFactoryType__","ÉµÉµdefineInjectable","signal","withProps","propsFactory","store","props","__spreadValues","STATE_SOURCE","__spreadProps","withComputed","signalsFactory","withHooks","hooksOrFactory","store","storeMembers","__spreadValues","STATE_SOURCE","hooks","createHook","name","hook","currentHook","__spreadProps","withMethods","methodsFactory","methods","withState","stateOrFactory","state","stateKeys","currentState","stateSignals","acc","key","sliceSignal","computed","toDeepSignal"],"x_google_ignoreList":[0]}